package Components;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Scanner;

public class TomasuloProgress {
    public HashMap<Integer, ReservationStationEntry> addReservationStations; // Use HashMap for add reservation stations
    public HashMap<Integer, ReservationStationEntry> mulReservationStations; // Use HashMap for mul reservation stations
    public HashMap<Integer, LoadBuffer> loadBuffers; // Use HashMap for load buffers
    public HashMap<Integer, StoreBuffer> storeBuffers; // Use HashMap for store buffers
    public int nextIssue;
    public int currentClock;
    // private List<InstructionHistoryEntry> instructionHistory;
    public HashMap<Integer, instruction> instructionQueue; // Use HashMap for instructions with indices as keys
    public HashMap<Integer, Integer> cache; // Memory cache
    public HashMap<Integer, RegFile> fpRegisters; // Floating-point registers
    public HashMap<Integer, RegFile> intRegisters; // Integer registers
    public HashMap<String, Integer> latencies; // Instruction latencies

    public TomasuloProgress() {
        this.instructionQueue = new HashMap<>();
        this.fpRegisters = new HashMap<>();
        this.intRegisters = new HashMap<>();
        this.addReservationStations = new HashMap<>();
        this.mulReservationStations = new HashMap<>();
        this.loadBuffers = new HashMap<>();
        this.storeBuffers = new HashMap<>();
    }


    public void generateInstructionQueueAsHashTable(int numnOfInstructions) {
        for (int i = 0; i < numnOfInstructions; i++) {
            instruction instruction =this.promptInstruction(i);
            instructionQueue.put(i, instruction);
        }
    }
    public instruction promptInstruction(int i) {
        Scanner scanner = new Scanner(System.in);
        // Prompt the user to enter an instruction
        System.out.print("Enter an instruction: ");
        String instruction = scanner.nextLine();
    //    scanner.close();
        instruction parsedInstruction = new instruction(instruction);
        return parsedInstruction ;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("Instruction Queue:\n");
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            Integer index = entry.getKey();
            instruction instr = entry.getValue();
            sb.append("Index ").append(index).append(": ").append(instr).append("\n");
        }
     //   this.populateRegFile();
        return sb.toString();
    }
      
    public void populateRegFile() {
        System.out.println("Populating Integer Registers...");
        
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            instruction instr = entry.getValue();

            String destinationReg = instr.instructionDestinationReg;
            String operand1Reg = instr.j;
            String operand2Reg = instr.k;

            // Check if destination register already exists
            if (!regFileContains(destinationReg)) {
                RegFile destinationRow = new RegFile(null, null, destinationReg);
                intRegisters.put(intRegisters.size(), destinationRow);
                System.out.println("Added to intRegisters: " + destinationRow);
            }

            // Check if operand1 register already exists
            if (operand1Reg.matches(".*[fF].*") && !regFileContains(operand1Reg)) {
                RegFile operand1Row = new RegFile(null, null, operand1Reg);
                intRegisters.put(intRegisters.size(), operand1Row);
                System.out.println("Added to intRegisters: " + operand1Row);
            }

            // Check if operand2 register already exists
            if (operand2Reg.matches(".*[fF].*") && !regFileContains(operand2Reg)) {
                RegFile operand2Row = new RegFile(null, null, operand2Reg);
                intRegisters.put(intRegisters.size(), operand2Row);
                System.out.println("Added to intRegisters: " + operand2Row);
            }
        }
    }

    // Helper method to check if a register already exists in the map
    private boolean regFileContains(String regName) {
        for (RegFile reg : intRegisters.values()) {
            if (reg.RegName.equalsIgnoreCase(regName)) {
                return true;
            }
        }
        return false;
    }

    
    
    public void printIntRegisters() {
        System.out.println("Integer Registers Content:");
        if (this.intRegisters.isEmpty()) {
            System.out.println("No entries in intRegisters.");
            return;
        }
        for (Map.Entry<Integer, RegFile> entry : this.intRegisters.entrySet()) {
            System.out.println("Index " + entry.getKey() + ": " + entry.getValue().toString());
        }
    }

    public void populateLoadBuffers() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter Number Of Load Buffers: ");
        String StringNumOfBuffers = scanner.nextLine();
        int numOfBuffers = Integer.parseInt(StringNumOfBuffers);
     //   scanner.close();
        // takes the number of wanted loadbuffers , in our design that means the number of rows in one load buffer 
    	// what we need to do is to dynamically add to the hashmap , that numofbuffers many times instances 
         for(int i=0;i<numOfBuffers;i++) {
	            LoadBuffer LoadBuffers = new LoadBuffer();
	            //created an instance of a load buffer , set the tag of each one 
	            LoadBuffers.Tag="L"+i;
	            //Add it to the hashmap
	            loadBuffers.put(i, LoadBuffers);
                  }
         }
    public void populateAddReservationStations() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter Number Of Reserv Add Stations: ");
        String StringNumOfAddResStations = scanner.nextLine();
        int NumOfAddResStations = Integer.parseInt(StringNumOfAddResStations);
        
        for(int i=0;i<NumOfAddResStations;i++) {
        	ReservationStationEntry AddResStation = new ReservationStationEntry();
        	AddResStation.Tag="A"+i;
        	addReservationStations.put(i, AddResStation);
        	
        }

    }
 
       public void HelperMethodForLoopingOnTheAddReservationStations(boolean noAvailableStation , instruction instr ) {
           for (Map.Entry<Integer, ReservationStationEntry> reservationAddStations : addReservationStations.entrySet()) {
               ReservationStationEntry addStation = reservationAddStations.getValue();
               if(!addStation.busy){
               	//Send the instruction to that station 
               	addStation.takeinstruction(instr, this.intRegisters);
                   noAvailableStation = false; // A station was found, so set the flag to false

                  break ;
               }
       }
       }
    public void FindResStation() {
        
        // Loop through the instruction queue        
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            Integer instructionIndex = entry.getKey();
            instruction instr = entry.getValue();
        	this.nextIssue=this.currentClock;
          instr.issue=this.nextIssue;
            // Get the operation type (e.g., ADD.D, MUL.D, etc.)
            String operation = instr.instructionOP;
            // Determine which reservation station to use based on the operation
            if (operation.equals(ALUOperations.Operation.ADD_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.ADD_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SUB_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SUB_S.getOperationName())) {
            	boolean noAvailableStation = true; // Flag to track if no station is available

          /*      for (Map.Entry<Integer, ReservationStationEntry> reservationAddStations : addReservationStations.entrySet()) {
                    ReservationStationEntry addStation = reservationAddStations.getValue();
                    if(!addStation.busy){
                    	//Send the instruction to that station 
                    	addStation.takeinstruction(instr, this.intRegisters);
                        noAvailableStation = false; // A station was found, so set the flag to false

                       break ;
                    } */
            	this.HelperMethodForLoopingOnTheAddReservationStations(noAvailableStation, instr);
                    //
                    if (noAvailableStation) {
// hna b2a logic el stalling , we should stop at this instruction till an instance of the reservation station is not busy 
                    	this.HelperMethodForLoopingOnTheAddReservationStations(noAvailableStation, instr);
                    }
                    //Here the issuing is done , we should execute 
                    this.execute(instr);

                }else if (operation.equals(ALUOperations.Operation.MUL_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.MUL_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.DIV_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.DIV_S.getOperationName())) {

                // Add the instruction to the MulReservationStations
                mulReservationStations.put(instructionIndex, new ReservationStationEntry());

            } else if (operation.equals(ALUOperations.Operation.LW.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.LD.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.L_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.L_D.getOperationName())) {

                // Add the instruction to the LoadBuffers
            	// Create An instance of the load buffer 
            	//Nah not creating , just access one of the nullified instances of the loadBuffers hashmap , first one whos attribute aint busy ?

                for (Map.Entry<Integer, LoadBuffer> LDbuffer : this.loadBuffers.entrySet()) {
                    LoadBuffer OneRowInLoadBuffer = LDbuffer.getValue();
                    
                    if(OneRowInLoadBuffer.busy==false) {
                    
                	OneRowInLoadBuffer.TakingInInstruction(instr, this.intRegisters);
                    System.out.println(OneRowInLoadBuffer.toString());
                    break;
                }
                }
                
                
                
                
                
                
            } else if (operation.equals(ALUOperations.Operation.SW.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SD.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.S_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.S_D.getOperationName())) {

                // Add the instruction to the StoreBuffers
                storeBuffers.put(instructionIndex, new StoreBuffer(instr));
            }
        }
    }

    
    
    
    //Execution Stage 
public void execute(instruction instruction) {
        
        // Iterate over all addReservationStations
        for (Map.Entry<Integer, ReservationStationEntry> entry : addReservationStations.entrySet()) {
            ReservationStationEntry station = entry.getValue();
              
       //    boolean flagkda=false;
            // Check if qj or qk is not empty (and not null)
            if (station.qj != null || station.qk != null) {
            System.out.println("the current add station contains q values skipping , because it should not start execution yet");
                continue; // Skip execution for this station
           }else{           

            
           // station.setOp();
            String operationName = station.op;   

            ALUOperations.Operation operation = ALUOperations.fromString(operationName);
            ALUOperations op= new ALUOperations();

            int executionFinishTime = this.currentClock + operation.getLatency() - 1;
    
            // Assign timeRemaining to latency if it's not already set
            //boolean preventInput=true ;
            if (station.timeRemaining == null  ) {
                //Scanner scanner = new Scanner(System.in);
                op.inputLatencies();
                station.timeRemaining=operation.getLatency();                
                //int instructionIndex = station.getInstructionIndex(); // Assuming you have a way to get the instruction index
                //instruction instr = instructionQueue.get(instructionIndex);
                
                instruction.executionStart=this.currentClock;
                System.out.println("Execution start set for instruction at index "  + " to clock cycle: " + this.currentClock);
                

                // i Want to set the executionStart of this instruction in the instructionQueue to the current clockCycle 
                //System.out.println("Execution started in ADD station. Time remaining set to: " + station.getTimeRemaining());

            }    if (station.timeRemaining > 0) {
            	station.timeRemaining=station.timeRemaining - 1;
                System.out.println("Executing in ADD station... Time remaining: " + station.timeRemaining);
            }
                
            // Check if execution is complete
            if (station.timeRemaining == 0) {

                //set execution finish to current clock +latency -1


                    switch (station.op) {
                        case "ADD.D":
                        case "ADD.S":
                        	station.result=station.vj + station.vk;
                            break;
                
                        case "SUB.D":
                        case "SUB.S":
                        	station.result=station.vj - station.vk;
                            break;
                
                        case "ADDI":
                        	station.result=station.vj + station.vk;
                            break;
                
                        case "SUBI":
                        	station.result=station.vj - station.vk;
                            break;
                        default:
                            System.out.println("Unsupported operation: " + station.op);
                            break;
                    }

                //instruction.setExecutionFinish(this.currentClock + operation.getLatency() - 1);
                 instruction.executionFinish=executionFinishTime;

                System.out.println("Execution finish set to: " + executionFinishTime);

                System.out.println("Execution complete in ADD station!");
          //      flagkda=true;
                station.timeRemaining=null;
                station.busy=false;

            }
        }
    }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    public static void main(String[] args) {
        TomasuloProgress tomasuloProgress = new TomasuloProgress();
        tomasuloProgress.currentClock=0;
        tomasuloProgress.generateInstructionQueueAsHashTable(1);
        tomasuloProgress.populateRegFile(); //Populating the regfile with registers names coming from the registers mentioned in each instruction
        tomasuloProgress.populateAddReservationStations();//Creating instances of the Reservation stations , as many as the user wants and assigining a tag for them

    	//while(true) {
        System.out.println(tomasuloProgress.toString()); //printing the instruction Queue
        tomasuloProgress.printIntRegisters();//Printing to check if the name population is done correctly
     //   tomasuloProgress.populateLoadBuffers();
        tomasuloProgress.FindResStation(); //Here is where we check the instruction , finding which station would it go for 
        tomasuloProgress.printIntRegisters(); //After passing the tag 
        tomasuloProgress.currentClock=tomasuloProgress.currentClock+1;
        
    	
    }
}