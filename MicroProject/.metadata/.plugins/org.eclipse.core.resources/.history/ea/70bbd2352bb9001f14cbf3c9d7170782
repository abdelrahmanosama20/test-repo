package Components;

import java.util.HashMap;
//import java.util.Scanner;
import java.util.Map;

public class LoadBuffer {
	public String Tag ;
    public boolean busy;
    public int address;
    public double result;
    public Integer timeRemaining; 
    public instruction instruction;
    public HashMap<Integer, RegFile> regFile; // Floating-point registers    
    public Cache cache;
    public Memory memory;
    public int Latency ;
    
 
// should also take the instance of the reg file 
  // the reg file would actually be a hashmap
public void TakingInInstruction(instruction instruction,HashMap<Integer, RegFile> regFile) {
	this.instruction=instruction;
	this.busy=true;
	this.regFile=regFile; 
	//Loop Thru the hashmap compare the destination register in the instruction with Attribute RegName
    for (Map.Entry<Integer, RegFile> entry : this.regFile.entrySet()) {
    	RegFile RegFileinstance = entry.getValue();
          if(instruction.instructionDestinationReg.equals(RegFileinstance.RegName)){
        	  RegFileinstance.q=this.Tag;
        	  break;
          }
};

}


public void IntializeTheCacheLinkToTheLoadBufferAndSettingTheLatencyAndTheMmeory(Cache cache,Memory memory) {
	this.cache=cache;
	this.memory=memory;
}



// Now we have the instruction , we should extract the operands calculate the address of the Memory where we will access to load 


//Execution Logic of the LOAD
public void CalculatingAddressAndAccessingMmeory() {
    // Assuming operands for the load are ready
    String TobeCastedtoIntegerFirstPartOfAddress = this.instruction.j;
    int FirstPartOfAddress = Integer.parseInt(TobeCastedtoIntegerFirstPartOfAddress);
    String ToBeCastedtoIntegerSecondPartOfAddress = this.instruction.k;
    if(ToBeCastedtoIntegerSecondPartOfAddress!=null) {
    int SecondPartOfAddress = Integer.parseInt(ToBeCastedtoIntegerSecondPartOfAddress);
    this.address = FirstPartOfAddress + SecondPartOfAddress; } else {
    	this.address=FirstPartOfAddress;
    }
    // Now, try to read from the cache
    System.out.println("Attempting to read data from cache...");
    Byte data = this.cache.readFromCache(this.address, this.memory);

    // Handle cache hit or miss
    if (this.cache.cacheMiss) {
        // Cache miss: fetch the block from memory
        System.out.println("Cache miss! Data not in cache.");
        // Optionally, simulate additional latency for memory access if needed
        int additionalLatency = 5; // Example: memory latency
        for (int i = 0; i < additionalLatency; i++) {
        }

        // Now the data should be available in the cache
        // No need to call readFromCache again; data is already available from the block fetched
        // This data has already been fetched into the cache by the previous call
        System.out.println("Cache miss handled, block loaded. Data: " + data);

        // Reset cacheMiss flag
        this.cache.cacheMiss = false;
    }
    
        // Cache hit: proceed with the data
        System.out.println("Cache hit! Data: " + data);
        ///Cache hit here we should take the data and set the regfile content and remove the tag 
        for (Map.Entry<Integer, RegFile> entry : this.regFile.entrySet()) {
        	RegFile RegFileinstance = entry.getValue();
              if(instruction.instructionDestinationReg.equals(RegFileinstance.RegName)){
            	  RegFileinstance.q=null;
            	  RegFileinstance.value=data;
            	  break;
              }
    };
    

}

@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("LoadBuffer Details:\n");
    sb.append("Tag: ").append(Tag).append("\n");
    sb.append("Busy: ").append(busy).append("\n");
    sb.append("Address: ").append(address).append("\n");
    sb.append("Result: ").append(result).append("\n");
    sb.append("Time Remaining: ").append(timeRemaining != null ? timeRemaining : "N/A").append("\n");
    return sb.toString();
}



public static void main(String[] args) {
    // Setup a basic scenario with mock data

    // Create cache and memory objects
    Cache cache = new Cache(50, 4);
    Memory memory = new Memory();

    // Initialize a simple instruction
    instruction instr = new instruction("L.D F6,100");

    // Create a register file with mock values
    HashMap<Integer, RegFile> regFile = new HashMap<>();
    regFile.put(1, new RegFile(null, null, "F6")); //value , tag , regname

    // Create the LoadBuffer and set up
    LoadBuffer loadBuffer = new LoadBuffer();
    loadBuffer.Tag = "T1"; // Set a tag for testing
    loadBuffer.IntializeTheCacheLinkToTheLoadBufferAndSettingTheLatencyAndTheMmeory(cache, memory);
    loadBuffer.TakingInInstruction(instr, regFile);

    // Run the address calculation and cache/memory access
    loadBuffer.CalculatingAddressAndAccessingMmeory();

    // Output the status of the LoadBuffer
    System.out.println(loadBuffer);

    // Output the updated register file
    for (Map.Entry<Integer, RegFile> entry : regFile.entrySet()) {
        System.out.println(entry.getValue());
    }
}
}




