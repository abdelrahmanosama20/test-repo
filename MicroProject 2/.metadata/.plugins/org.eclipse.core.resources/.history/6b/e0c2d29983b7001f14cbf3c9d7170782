package Components;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Scanner;

public class TomasuloProgress {
    public HashMap<Integer, ReservationStationEntry> addReservationStations; // Use HashMap for add reservation stations
    public HashMap<Integer, ReservationStationEntry> mulReservationStations; // Use HashMap for mul reservation stations
    public HashMap<Integer, LoadBuffer> loadBuffers; // Use HashMap for load buffers
    public HashMap<Integer, StoreBuffer> storeBuffers; // Use HashMap for store buffers
    public int nextIssue;
    public int currentClock;
    // private List<InstructionHistoryEntry> instructionHistory;
    public HashMap<Integer, instruction> instructionQueue; // Use HashMap for instructions with indices as keys
    public HashMap<Integer, Integer> cache; // Memory cache
    public HashMap<Integer, RegFile> fpRegisters; // Floating-point registers
    public HashMap<Integer, RegFile> intRegisters; // Integer registers
    public HashMap<String, Integer> latencies; // Instruction latencies

    public TomasuloProgress() {
        this.instructionQueue = new HashMap<>();
        this.fpRegisters = new HashMap<>();
        this.intRegisters = new HashMap<>();
        this.addReservationStations = new HashMap<>();
        this.mulReservationStations = new HashMap<>();
        this.loadBuffers = new HashMap<>();
        this.storeBuffers = new HashMap<>();
    }


    public void generateInstructionQueueAsHashTable(int numnOfInstructions) {
        for (int i = 0; i < numnOfInstructions; i++) {
            instruction instruction =this.promptInstruction(i);
            instructionQueue.put(i, instruction);
        }
    }
    public instruction promptInstruction(int i) {
        Scanner scanner = new Scanner(System.in);
        // Prompt the user to enter an instruction
        System.out.print("Enter an instruction: ");
        String instruction = scanner.nextLine();
    //    scanner.close();
        instruction parsedInstruction = new instruction(instruction);
        return parsedInstruction ;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("Instruction Queue:\n");
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            Integer index = entry.getKey();
            instruction instr = entry.getValue();
            sb.append("Index ").append(index).append(": ").append(instr).append("\n");
        }
     //   this.populateRegFile();
        return sb.toString();
    }

    
    //Created the instruction Queue successfully 
      // now we need to populate the RegFile , with the destination Registers in all the instructions in the queue for the names
     /// Null for the q feild , and null for the value 
    public void populateRegFile() {
        System.out.println("Populating Integer Registers...");
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            instruction instr = entry.getValue();
            String destinationReg = instr.getInstructionDestinationReg();
            System.out.println("Destination Register: " + destinationReg);

            RegFile rowInRegFile = new RegFile(null, null, destinationReg);
            this.intRegisters.put(entry.getKey(), rowInRegFile);

            System.out.println("Added to intRegisters: " + rowInRegFile);
        }
    }
       
    public void printIntRegisters() {
        System.out.println("Integer Registers Content:");
        if (this.intRegisters.isEmpty()) {
            System.out.println("No entries in intRegisters.");
            return;
        }
        for (Map.Entry<Integer, RegFile> entry : this.intRegisters.entrySet()) {
            System.out.println("Index " + entry.getKey() + ": " + entry.getValue().toString());
        }
    }


    
    
    
    public void populateLoadBuffers() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter Number Of Load Buffers: ");
        String StringNumOfBuffers = scanner.nextLine();
        int numOfBuffers = Integer.parseInt(StringNumOfBuffers);
     //   scanner.close();
        // takes the number of wanted loadbuffers , in our design that means the number of rows in one load buffer 
    	// what we need to do is to dynamically add to the hashmap , that numofbuffers many times instances 
         for(int i=0;i<numOfBuffers;i++) {
	            LoadBuffer LoadBuffers = new LoadBuffer();
	            //created an instance of a load buffer , set the tag of each one 
	            LoadBuffers.Tag="Tag"+i;
	            //Add it to the hashmap
	            loadBuffers.put(i, LoadBuffers);
                  }
         }
 
       

    public void FindResStation() {
        
        // Loop through the instruction queue        
        for (Map.Entry<Integer, instruction> entry : instructionQueue.entrySet()) {
            Integer instructionIndex = entry.getKey();
            instruction instr = entry.getValue();

            // Get the operation type (e.g., ADD.D, MUL.D, etc.)
            String operation = instr.getInstructionOP();
            // Determine which reservation station to use based on the operation
            if (operation.equals(ALUOperations.Operation.ADD_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.ADD_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SUB_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SUB_S.getOperationName())) {

                    //LOOP FOO2 HENA checking if at least one station is busy or not (iterating over the whole hashmap)
                // Add the instruction to the AddReservationStations
                for (Map.Entry<Integer, ReservationStationEntry> reservationAddStations : addReservationStations.entrySet()) {
                    ReservationStationEntry addStation = reservationAddStations.getValue();
                    if(!addStation.busy){
                    //   addReservationStations.put(instructionIndex, new ReservationStationEntry());
                       addStation.takeinstruction(instr); // set the instruction in the reservation file 
                       break ;
                    }

                }

            } else if (operation.equals(ALUOperations.Operation.MUL_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.MUL_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.DIV_D.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.DIV_S.getOperationName())) {

                // Add the instruction to the MulReservationStations
                mulReservationStations.put(instructionIndex, new ReservationStationEntry());

            } else if (operation.equals(ALUOperations.Operation.LW.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.LD.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.L_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.L_D.getOperationName())) {

                // Add the instruction to the LoadBuffers
            	// Create An instance of the load buffer 
            	//Nah not creating , just access one of the nullified instances of the loadBuffers hashmap , first one whos attribute aint busy ?

                for (Map.Entry<Integer, LoadBuffer> LDbuffer : this.loadBuffers.entrySet()) {
                    LoadBuffer OneRowInLoadBuffer = LDbuffer.getValue();
                    
                    if(OneRowInLoadBuffer.busy==false) {
                    
                	OneRowInLoadBuffer.TakingInInstruction(instr, this.intRegisters);
                    System.out.println(OneRowInLoadBuffer.toString());
                    break;
                }
                }
                
                
                
                
                
                
            } else if (operation.equals(ALUOperations.Operation.SW.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.SD.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.S_S.getOperationName()) ||
                    operation.equals(ALUOperations.Operation.S_D.getOperationName())) {

                // Add the instruction to the StoreBuffers
                storeBuffers.put(instructionIndex, new StoreBuffer(instr));
            }
        }
    }



    public static void main(String[] args) {
        TomasuloProgress tomasuloProgress = new TomasuloProgress();
        tomasuloProgress.generateInstructionQueueAsHashTable(1);
        System.out.println(tomasuloProgress.toString());
        tomasuloProgress.populateRegFile();
        tomasuloProgress.printIntRegisters();
        tomasuloProgress.populateLoadBuffers();
        tomasuloProgress.FindResStation();
        tomasuloProgress.printIntRegisters();

    }
}